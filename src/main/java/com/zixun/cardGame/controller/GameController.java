package com.zixun.cardGame.controller;

import com.zixun.cardGame.animation.CardAnimator;
import com.zixun.cardGame.behavior.CardEffectResult;
import com.zixun.cardGame.manager.TriggerManager;
import com.zixun.cardGame.model.overlay.BaseOverlay;
import com.zixun.cardGame.model.overlay.InfoOverlay;
import com.zixun.cardGame.model.overlay.PileOverlay;
import com.zixun.cardGame.observer.EventListener;
import com.zixun.cardGame.observer.EventManager;
import com.zixun.cardGame.event.GameStateChangedEvent;
import com.zixun.cardGame.manager.GameEngine;
import com.zixun.cardGame.observer.Observer;
import com.zixun.cardGame.manager.DeckManager;
import com.zixun.cardGame.manager.GameManager;
import com.zixun.cardGame.map.LayeredGameMap;
import com.zixun.cardGame.map.MapNode;
import com.zixun.cardGame.type.CardViewSize;
import com.zixun.cardGame.type.TargetType;
import com.zixun.cardGame.util.*;
import com.zixun.cardGame.model.card.Card;
import com.zixun.cardGame.model.character.Monster;
import com.zixun.cardGame.model.character.Player;

import com.zixun.cardGame.model.relic.Relic;
import com.zixun.cardGame.type.GameControllerState;
import com.zixun.cardGame.type.GameEngineState;
import com.zixun.cardGame.model.overlay.PauseOverlay;
import com.zixun.cardGame.view.BuffRenderer;
import com.zixun.cardGame.view.CardView;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;

import javafx.scene.shape.Polygon;
import javafx.scene.effect.DropShadow;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayDeque;

import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.image.ImageView;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.transform.Rotate;

import java.util.*;
import java.util.List;

import static com.zixun.cardGame.type.GameEngineState.*;
import static com.zixun.cardGame.type.GameControllerState.*;
import static com.zixun.cardGame.type.NodeTypeEnum.*;

public class GameController {

    @FXML private StackPane rootPane;
    @FXML private VBox mainMenuPane;
    @FXML private BorderPane gameContent;
    @FXML private AnchorPane battleLogPane;

    // Select
    @FXML private BorderPane roleSelectPane;
    @FXML private VBox classBtnBar, infoBar;
    @FXML private Button btnWarrior, btnMage, btnRogue;

    // Shared Top
    @FXML private HBox Top;
    @FXML private Label playerHpLabelTop;
    @FXML private Label goldLabel;
    @FXML private Label floorLabel;
    @FXML private Label levelLabel;
    @FXML private Label cardHoldTop;
    @FXML private HBox relicBar;
    @FXML private Button openInventoryButton;

    // CenterMap
    @FXML private AnchorPane mapPane;
    @FXML private ScrollPane mapScroll;
    @FXML private StackPane layerStack;
    @FXML private GridPane mapGrid;
    @FXML private Pane pathLayer;
    @FXML private Label cardInExhaustLabel;

    // CenterBattle
    @FXML private AnchorPane battlePane;
    @FXML private ProgressBar playerHpBar;
    @FXML private Label playerBlockLabel;
    @FXML private Label playerHpValueLabel;
    @FXML private FlowPane playerBuffBar;
    @FXML private FlowPane monsterBuffBar;
    @FXML private Label monsterIntentLabel;
    @FXML private ImageView playerImageView;
    @FXML private ImageView monsterImageView;
    @FXML private ProgressBar monsterHpBar;
    @FXML private Label monsterHpValueLabel;
    @FXML private Label monsterBlockLabel;
    @FXML  private Label battleRoundLabel;
    @FXML private Label battleMonsterNameLabel;
    @FXML private ListView<String> gameLog;
    @FXML private Region centerArea;
    @FXML private VBox playerArea;
    @FXML private VBox monsterArea;


    // BottomBattle
    @FXML private Label cardInDeckLabel;
    @FXML private Label cardInDiscardLabel;
    @FXML private HBox handCardBox;
    @FXML private Label epLabel;
    @FXML private Button endTurnBtn;

    // ÂºÉÁî®
    @FXML private Button useBtn;
    @FXML private Button discardBtn;
    @FXML private Button drawBtn;

    private static final GameManager gameManager = GameManager.getInstance();
    private final GameEngine engine = GameEngine.getInstance();
    private final TriggerManager triggerManager = TriggerManager.getInstance();
    private final DeckManager deckManager = new DeckManager();
    private GameControllerState currentMode;
    private Player player;

    private Observer<Player> playerObserver;
    private Observer<Monster> monsterObserver;
    private EventListener<GameStateChangedEvent> gameStateChangedEventEventListener;
    private final Deque<Node> overlayStack = new ArrayDeque<>();

    private static boolean isFirstTime = true;
    private boolean gameOverHandled = false;
    private boolean rendering = false;
    private boolean isESCMenuOpen = false;
    private PauseOverlay pauseOverlay;

    // ÊîæÊäñÂä®
    private long lastEscPressTime = 0;
    private static final long ESC_DEBOUNCE_MS = 200;
    // UI
    public static final int CELL = 50;
    public static final int GAP = 30;

    private CardAnimator cardAnimator;
    // Âç°ÁâåÊãñÊãΩ
    private CardView draggingCard;
    private Card cardBeingDragged;
    private double offsetX, offsetY;
    private boolean isAiming = false;

    private final Line arrow = new Line();
    private static final double ARROW_THICKNESS = 6;
    private static final double ARROW_HEAD_H    = 36;

    private boolean arrowReady = false;
    private Point2D currentMousePosition = new Point2D(0, 0);
    private Point2D returnPos;
    private Pane dragOriginParent;
    private int  dragOriginIndex;
    private final Polygon  arrowHead = new Polygon();
    private enum DragPhase { NONE, DRAGGING, FLYING }
    private DragPhase dragPhase = DragPhase.NONE;
    private final Map<MapNode, Button> nodeToButtonMap = new HashMap<>();


    // ÂàáÊç¢Ê®°Âºè
    public void switchToMode(GameControllerState mode) {
        if (mode == ROLE_SELECT_CONTROLLER) {
            closeAllOverlays();
        }
        currentMode = mode;
        mainMenuPane.setVisible(mode == MAIN_MENU_CONTROLLER);
        roleSelectPane.setVisible(mode == ROLE_SELECT_CONTROLLER);
        mapPane.setVisible(mode == MAP_TURN_CONTROLLER);
        gameContent.setVisible(mode == MAP_TURN_CONTROLLER || mode == BATTLE_CONTROLLER);
        battleLogPane.setVisible(mode == MAP_TURN_CONTROLLER || mode == BATTLE_CONTROLLER);
        battlePane.setVisible(mode == BATTLE_CONTROLLER);
    }

    @FXML
    private void initialize() {
        System.out.println("initializing");
        // ESCÂäüËÉΩ
        rootPane.sceneProperty().addListener((
                obs, o, scene) -> {
            if (scene != null) {
                registerGlobalEscHandler(scene);
            }
        });
        // GameStatus Áä∂ÊÄÅÂèòÂåñÁõëÂê¨
        EventManager.addListener(GameStateChangedEvent.class, event -> {
            if (event.getNewState() == GAME_OVER) {
                Platform.runLater(this::checkIfGameOver);
            }
            updateUI();
        });
        engine.setBattleButtonsHandler(this::setAllBattleActionButtonsEnabled);

        switchToMode(MAIN_MENU_CONTROLLER);

        infoBar.widthProperty().addListener((obs, o, w) -> syncWidths(w.doubleValue() / 3));
        classBtnBar.widthProperty().addListener((obs, o, w) -> syncWidths(w.doubleValue() / 3));

        // UI
        mapGrid.setAlignment(Pos.TOP_CENTER);
        mapGrid.setHgap(GAP);
        mapGrid.setVgap(GAP);
        initArrow();

        // Log Ëá™ÂÆö‰πâ
        gameLog.setCellFactory(lv -> new ListCell<>() {
            private final Label label = new Label();
            {
                label.setWrapText(true);
                label.setMaxWidth(200);
            }
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setGraphic(null);
                } else {
                    label.setText(item);
                    // üåü Âà§Êñ≠ÂÜÖÂÆπÂâçÁºÄÂÜ≥ÂÆöÈ¢úËâ≤
                    if (item.startsWith("[MONSTER]")) {
                        label.setTextFill(Color.CRIMSON);
                    } else if (item.startsWith("[PLAYER]")) {
                        label.setTextFill(Color.ROYALBLUE);
                    } else {
                        label.setTextFill(Color.BLACK); // ÈªòËÆ§È¢úËâ≤
                    }

                    label.setText(item
                            .replace("[MONSTER]","")
                            .replace("[PLAYER]", "")); // ÂéªÊéâÂÖ®ÈÉ®
                    setGraphic(label);
                }
            }
        });
        // Log ÊªöÂä® ËÆ© ListView ÂÖàÂáÜÂ§áÂ•ΩÊªöÂä®Êù°
        Platform.runLater(() -> {
            ScrollBar vBar = (ScrollBar) gameLog.lookup(".scroll-bar:vertical");
            if (vBar != null) vBar.setUnitIncrement(8);   // ÂèØÈÄâÔºöË∞ÉÊªöÂä®ÁÅµÊïèÂ∫¶
        });
        // Scene ÂàõÂª∫ÂêéÂÜçÊ≥®ÂÜåËøáÊª§Âô®
        rootPane.sceneProperty().addListener((obs, o, scene) -> {
            if (scene == null) return;

            scene.addEventFilter(ScrollEvent.SCROLL, e -> {

                if (!battleLogPane.isVisible()) return;   // Êó•ÂøóÈöêËóèÊó∂ÂøΩÁï•

                // Êää battleLogPane ÁöÑÂ±ÄÈÉ®ÂùêÊ†áËΩ¨Êàê Scene ÂùêÊ†á
                Bounds logBounds = battleLogPane.localToScene(
                        battleLogPane.getLayoutBounds());

                boolean inside = logBounds.contains(e.getSceneX(), e.getSceneY());
                if (!inside) return;                      // Èº†Ê†á‰∏çÂú®Êó•Âøó ‚Üí ËÆ©Âú∞ÂõæÊªö

                // ---------- ÊâãÂä®ÊªöÊó•Âøó ----------
                // ÊñπÊ≥ï AÔºöÁõ¥Êé•ÊîπÊªöÂä®Êù°
                ScrollBar vBar = (ScrollBar) gameLog.lookup(".scroll-bar:vertical");
                if (vBar != null) {
                    double step = vBar.getUnitIncrement();        // ÊØèÊ†ºÂ¢ûÈáè‚âà‰∏ÄË°å
                    double delta = Math.signum(e.getDeltaY()) * step;
                    vBar.setValue(clamp(vBar.getValue() - delta,
                            vBar.getMin(), vBar.getMax()));
                }
                // ÊñπÊ≥ï BÔºàÊõ¥ÁÆÄÂçï‰ΩÜË∑≥Ë∑ÉÊÑüÂ§ßÔºâÔºöÊåâÁ¥¢ÂºïÊªö
                // int lines = e.getDeltaY() > 0 ? -3 : 3;
                // gameLog.scrollTo(gameLog.getSelectionModel().getSelectedIndex() + lines);

                e.consume();   // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜçÂÜíÊ≥°Âà∞Âú∞Âõæ
            });
        });

        // pathLayer ÁªëÂÆöÂÆΩÈ´òÔºà‰ΩÜ‰∏çÁªë layoutX/YÔºâ
        pathLayer.prefWidthProperty().bind(layerStack.widthProperty());
        pathLayer.prefHeightProperty().bind(layerStack.heightProperty());

        Log.bind(gameLog);

        // ÁâåÂ†ÜÊòæÁ§∫
        cardInDeckLabel.setOnMouseClicked(e ->
                OverlayUtil.openOverlay(rootPane, overlayStack,
                        () -> new PileOverlay("ÊäΩÁâåÂ†Ü",
                                deckManager.getDeckPile(),
                                player,
                                rootPane,
                                overlayStack)));

        cardInDiscardLabel.setOnMouseClicked(e ->
                OverlayUtil.openOverlay(rootPane, overlayStack,
                        () -> new PileOverlay("ÂºÉÁâåÂ†Ü",
                                deckManager.getDiscardPile(),
                                player,
                                rootPane,
                                overlayStack)));

        cardInExhaustLabel.setOnMouseClicked(e ->
                OverlayUtil.openOverlay(rootPane, overlayStack,
                        () -> new PileOverlay("Ê∂àÂ§±ÁâåÂ†Ü",
                                deckManager.getExhaustPile(),
                                player,
                                rootPane,
                                overlayStack)));

        // Animator
        cardAnimator = new CardAnimator(rootPane, handCardBox, cardInDeckLabel, cardInDiscardLabel,
                this::createInteractiveCardView,
                this::renderHand);

        deckManager.addDrawListener(card -> { // Ê≥®ÂÜåÁõëÂê¨
            cardAnimator.flyDraw(card);
        });
        gameOverHandled = false;
    }
    private static double clamp(double v, double min, double max) {
        return v < min ? min : (v > max ? max : v);
    }

    public void initWithPlayerAndDeck(Player player) {
        this.player = player;
        engine.resetEngineToRoleSelect();

        GameManager.getInstance().resetToLayeredGameMap();
        startNewLevel();

        centerScroll();
        updateUI();
    }

    private void startNewLevel() {
        if (isFirstTime) {
            isFirstTime = false;
        } else {
            gameManager.moveToNextLevel();
        }

        // ÂèñÊ∂àÊóßÊÄ™Áâ©ÁöÑ Observer
        if (engine.getMonster() != null && monsterObserver != null) {
            engine.getMonster().removeObserver(monsterObserver);
        }

        // Áé©ÂÆ∂‰ΩçÁΩÆÂà∑Êñ∞
        LayeredGameMap currentMap = gameManager.getCurrentLevel().getLayeredGameMap();
        currentMap.resetPlayerToStart();
        MapNode start = currentMap.getStartNode();

        currentMap.moveTo(start);
        if (gameManager.getCurrentLevelNumber() == 1 && !start.isVisited()) {
            start.setVisited(true);
            onEnterNode(start);
        } else {
            start.setVisited(true);
        }

        // ËÆæÁΩÆÂàùÂßãÁä∂ÊÄÅÂú® MAP_TURN, Âà∑Êñ∞ shop, ÂõûÂà∞Âú∞Âõæ
        engine.setState(GameEngineState.MAP_TURN_ENGINE);
        switchToMode(getUIState(engine.getState()));

        Log.clear();
        Log.write("ËøõÂÖ•Á¨¨ " + gameManager.getCurrentLevelNumber() + " Â±ÇËø∑ÂÆ´!");

        centerScroll();

        updateUI();
    }

    public void updateUI() {
        GameEngineState state = engine.getState();
        GameControllerState UIState = getUIState(state);
        if (UIState != currentMode) {
            switchToMode(UIState); // Âè™ÊúâÁä∂ÊÄÅÂèëÁîüÂèòÂåñÊâçÂàáÊç¢
        }

        switch (UIState) {
            case ROLE_SELECT_CONTROLLER -> {
            }
            case MAP_TURN_CONTROLLER -> {
                updateMapStatusBar();
                renderMap(gameManager.getCurrentLevel().getLayeredGameMap());
            }
            case BATTLE_CONTROLLER -> {
                updateBattleInfo();
                updateMapStatusBar();
            }
        }
        renderRelics();
    }

    public void renderHand() {
        handCardBox.getChildren().clear();
        for (Card card : deckManager.getHand()) {
            handCardBox.getChildren().add(createInteractiveCardView(card));
        }
    }

    public void renderMap(LayeredGameMap layeredGameMap) {
        if (rendering) return;
        rendering = true;

        mapGrid.getChildren().clear();
        pathLayer.getChildren().clear();
        int totalRows = layeredGameMap.getMapRows().size();
        MapNode startNode = layeredGameMap.getStartNode();
        MapNode playerNode = layeredGameMap.getPlayerNode();
        Button playerButton = null;

        // Ê∑ªÂä†Âú∞ÂõæÊåâÈíÆ Buttons
        for (List<MapNode> rowNodes : layeredGameMap.getMapRows()) {
            for (MapNode node : rowNodes) {
                int uiRow = totalRows - 1 - node.row;
                int uiCol = layeredGameMap.getUiCol(node);

                // ÂàõÂª∫ÊåâÈíÆ
                Button button = new Button(node.content.getName());
                button.setPrefSize(CELL, CELL);
                button.setShape(new javafx.scene.shape.Circle(CELL / 2.0)); // ÂúÜÂΩ¢
                String fill = switch (node.content) {          // import static com.zixun.cardGame.type.NodeContentEnum.*;
                    case ENEMY      -> "#ffcccc";   // ÊµÖÁ∫¢
                    case MINI_BOSS      -> "#d5a6ff";   // Á¥´
                    case FINAL_BOSS       -> "#ff9b00";   // Ê©ô
                    case TREASURE      -> "#ffd700";   // Èáë
                    case EVENT      -> "#fff799";   // ÈªÑ
                    case REST       -> "#99ccff";   // Ëìù
                    case SHOP       -> "#9acd32";   // Áªø
                    default         -> "#ffffff";   // ÂÖ∂‰ªñ ÁôΩ
                };
                String baseStyle = String.format("""
                            -fx-background-color: %s;
                            -fx-background-radius: 50%%;
                            -fx-font-weight: bold;
                            -fx-font-size: 10;
                        """, fill);
                button.setStyle(baseStyle);

                // Áé©ÂÆ∂Ê†º ÁâπÊÆäÂåñ
                if (node == startNode) {
                    Button dummy = new Button();
                    dummy.setPrefSize(CELL, CELL);      // ‰ªçÁªôÊ≠£Â∏∏Â∞∫ÂØ∏ÔºåScrollPane ÊâçËÉΩÊ≠£Á°ÆËÆ°ÁÆóÈ´òÂ∫¶
                    dummy.setVisible(false);            // ÂÆåÂÖ®‰∏çÂèØËßÅÔºå‰ΩÜ‰ªçÂèÇ‰∏éÂ∏ÉÂ±Ä
                    GridPane.setRowIndex(dummy, uiRow);
                    GridPane.setColumnIndex(dummy, uiCol);
                    mapGrid.getChildren().add(dummy);
                    nodeToButtonMap.put(node, dummy);   // ‰æõËøûÁ∫øÊàñÊªöÂä®Êó∂ÂèñÂùêÊ†á
                    continue;
                } else if (node == playerNode) {
                    button.setStyle("-fx-border-color: blue; -fx-border-width: 3px;");
                    playerButton = button;
                } else if (layeredGameMap.canMove(playerNode, node)) {
                    button.setOnAction(e -> {
                        layeredGameMap.moveTo(node);
                        renderMap(layeredGameMap);
                        onEnterNode(node);
                    });
                    button.setStyle(button.getStyle() + """
                                ; -fx-border-color: #4caf50;
                                -fx-border-width: 2px;
                                -fx-background-color: #f0fff0;
                            """);
                } else {
                    button.setDisable(true);
                    button.setMouseTransparent(true); // ‰∏çÂìçÂ∫îÁÇπÂáª
                    button.setFocusTraversable(false); // ‰∏çËÉΩË¢´ Tab ÈîÆÈÄâ‰∏≠
                    button.setStyle(button.getStyle() + "; -fx-opacity: 1;"); // ÊÅ¢Â§ç‰∏çÈÄèÊòéÔºàÂèñÊ∂àÁÅ∞ÊéâÔºâ
                }

                // ÂÄíÊéí
                GridPane.setRowIndex(button, uiRow);
                GridPane.setColumnIndex(button, uiCol);
                mapGrid.getChildren().add(button);
                nodeToButtonMap.put(node, button);
            }
        }
        mapGrid.applyCss();
        mapGrid.layout();
        Platform.runLater(() -> {
            // Lines
            for (List<MapNode> rowNodes : layeredGameMap.getMapRows()) {
                for (MapNode node : rowNodes) {
                    if (node == startNode) continue;
                    int uiRow = totalRows - 1 - node.row;
                    int colA = layeredGameMap.getUiCol(node);

                    int nextRowIdx = node.row + 1;
                    if (nextRowIdx >= layeredGameMap.getMapRows().size()) continue;
                    for (MapNode down : layeredGameMap.getMapRows().get(nextRowIdx)) {
                        if (down == startNode) continue;
                        if (!layeredGameMap.canMove(node, down)) continue;
                        int colB = layeredGameMap.getUiCol(down);

                        Button btnA = getButtonAt(mapGrid, uiRow, colA);
                        Button btnB = getButtonAt(mapGrid, uiRow - 1, colB);
                        if (btnA == null || btnB == null) continue;

                        Point2D p1 = pathLayer.sceneToLocal(
                                btnA.localToScene(btnA.getWidth() / 2, btnA.getHeight() / 2).add(0, 6));
                        Point2D p2 = pathLayer.sceneToLocal(
                                btnB.localToScene(btnB.getWidth() / 2, btnB.getHeight() / 2).add(0, -6));
                        Line line = new Line(p1.getX(), p1.getY(), p2.getX(), p2.getY());
                        line.setStrokeWidth(2.5);
                        line.setStroke(Color.web("#9d744a"));
                        line.setStrokeLineCap(StrokeLineCap.ROUND);
                        pathLayer.getChildren().add(line);
                    }
                }
            }
        });
        centerScroll();
        rendering = false;
    }

    private Button getButtonAt(GridPane grid, int row, int col) {
        for (Node node : grid.getChildren()) {
            Integer r = GridPane.getRowIndex(node);
            Integer c = GridPane.getColumnIndex(node);
            if (r != null && c != null && r == row && c == col && node instanceof Button btn) return btn;
        }
        return null;
    }

    public void renderRelics() {
        relicBar.getChildren().clear();
        List<Relic> relicList = player.getRelicList();
        for (Relic relic : relicList) {
            Label label = new Label(relic.getName());
            label.setStyle("-fx-background-color: lightgoldenrodyellow; -fx-padding: 5 10 5 10; -fx-border-color: darkgoldenrod;");

            PopupHelper.bind(label, relic.getDescription());
            relicBar.getChildren().add(label);
        }
    }


    public void renderBattleRelics() {
        relicBar.getChildren().clear();
        List<Relic> relicList = player.getRelicList();
        for (Relic relic : relicList) {
            Label label = new Label(relic.getName());
            label.setStyle("-fx-background-color: lightgoldenrodyellow; -fx-padding: 5 10 5 10; -fx-border-color: darkgoldenrod;");
            PopupHelper.bind(label, relic.getDescription());

            relicBar.getChildren().add(label);
        }
        goldLabel.setText("ÈáëÂ∏Å: " + player.getGold());
    }

    private void updateMapStatusBar() {
        playerHpLabelTop.setText("HP: " + player.getHp() + " / " + player.getMaxHp());
        goldLabel.setText("ÈáëÂ∏Å: " + player.getGold());
        levelLabel.setText("Á¨¨ " + gameManager.getCurrentLevelNumber() + " Â±Ç / ÂÖ± " + gameManager.getLevelsSize() + " Â±Ç");
        cardHoldTop.setText("Âç°ÁâåÊåÅÊúâ: " + deckManager.getAllCards().size() + " ÊåÅÊúâ‰∏äÈôê: " + DeckManager.MAX_DECK);
    }

    public void updateBattleInfo() {
        updateBattlePlayerInfo();
        updateBattleMonsterInfo();
        BuffRenderer.renderAll(player, playerBuffBar);
        BuffRenderer.renderAll(engine.getMonster(), monsterBuffBar);
        epLabel.setText("EPÔºö " + getEpBar());
        cardInDeckLabel.setText("ÊäΩÁâåÊ±†: " + deckManager.getDeckSize() + " ");
        cardInDiscardLabel.setText(" ÂºÉÁâåÊ±†: " + deckManager.getDiscardSize() + " ");
        refreshExhaustCount();
    }

    public String getEpBar() {
        return " " + player.getEp() + " / " + player.getMaxEp();
    }

    public void updateBattlePlayerInfo() {
        int playerCurrentHp = player.getHp();
        if (playerCurrentHp > 0) {
            playerHpBar.setProgress(player.getHp() * 1.0 / player.getMaxHp());
            playerHpValueLabel.setText(player.getHp() + " / " + player.getMaxHp());
        } else {
            playerHpBar.setProgress(0 * 1.0 / player.getMaxHp());
            playerHpValueLabel.setText("0 / " + player.getMaxHp());
        }
        playerBlockLabel.setText("Êä§Áî≤: " + player.getBlock());
    }

    public void updateBattleMonsterInfo() {
        Monster monster = engine.getMonster();
        battleMonsterNameLabel.setText(engine.getMonster().getName());
        if (monster.getHp() > 0) {
            monsterHpBar.setProgress(monster.getHp() * 1.0 / monster.getMaxHp());
            monsterHpValueLabel.setText(monster.getHp() + " / " + monster.getMaxHp());
        } else {
            monsterHpBar.setProgress(0 * 1.0 / monster.getMaxHp());
            monsterHpValueLabel.setText("0 / " + monster.getMaxHp());
        }
        monsterBlockLabel.setText("Êä§Áî≤: " + monster.getBlock());

        if (engine.getState() == PLAYER_TURN) {
            monsterIntentLabel.setText(engine.getMonsterNextIntentDescription());
        } else {
            monsterIntentLabel.setText("");
        }
    }

    private void onEnterNode(MapNode node) {
        gameOverHandled = false;
        NodeEventProcessor.processNode(this, node);
    }

    public void startBattle(Monster monster) {

        // ‰øùÂ≠òËøõÂÖ•ÊàòÊñóÁöÑÊ†ºÂ≠ê‰ΩçÁΩÆ
        gameManager.setBattleStartNode(gameManager.getCurrentLevel().getLayeredGameMap().getPlayerNode());

        // Âà†Èô§ÊóßÁöÑ Observer
        if (engine.getMonster() != null && monsterObserver != null) {
            engine.getMonster().removeObserver(monsterObserver);
        }
        // ÂàõÂª∫Áé©ÂÆ∂ÔºåÊÄ™Áâ©ÔºåÂç°Áâå, PLAYER_TURN
        engine.initialize(player, monster, gameManager.getCurrentLevelNumber(), deckManager, this);

        // Ê≥®ÂÜåÁé©ÂÆ∂ Observer
        playerObserver = p -> updateBattlePlayerInfo();
        player.addObserver(playerObserver);

        // Ê≥®ÂÜåÊÄ™Áâ© Observer
        monsterObserver = m -> updateBattleMonsterInfo();
        engine.getMonster().addObserver(monsterObserver);

        // Êç¢Âú∫ÊôØ ÈªòËÆ§ PLAYER_TURN -> Êò†Â∞ÑÊàêUIÁöÑBATTLE_CONTROLLER
        switchToMode(getUIState(engine.getState()));

        updateUI();
        renderBattleRelics();
    }

    private void checkIfGameOver() {

        if (gameOverHandled || engine.getState() != GAME_OVER) { return; }
        gameOverHandled = true;

        if (player.getHp() <= 0) {
            Map<String, Runnable> buttonMap = new LinkedHashMap<>();
            buttonMap.put("ÈáçÊñ∞ÂºÄÂßã", this::doRestartClick);
            buttonMap.put("ËøîÂõû‰∏ªËèúÂçï", this::backToMainMenu);
            buttonMap.put("ÈÄÄÂá∫Ê∏∏Êàè", this::exitGame);
            showInfoDialog("ÂèØÊÉú", "‰Ω†Ê≠ª‰∫ÜÔºÅÊ∏∏ÊàèÁªìÊùüÔºÅ", buttonMap);
        } else if (gameManager.getBattleStartNode().type == BOSS) {
            if (gameManager.hasMoreLevel()) {
                showInfoDialog("‰Ω†‰∏ÄÈòµÁøªÊâæ", "ÂèëÁé∞‰∫Ü‰∏Ä‰∏™ÈÄöÈÅì", Map.of(
                        "ÂâçÂæÄ‰∏ã‰∏ÄÂ±Ç...", this::doNextLevel
                ));
                BattleRewardProcessor.showRandomRewardLevelBoss(this);
            } else {
                Map<String, Runnable> buttonMap = new LinkedHashMap<>();
                buttonMap.put("ÈáçÊñ∞ÂºÄÂßã", this::doRestartClick);
                buttonMap.put("ËøîÂõû‰∏ªËèúÂçï", this::backToMainMenu);
                buttonMap.put("ÈÄÄÂá∫Ê∏∏Êàè", this::exitGame);
                showInfoDialog("ËÉúÂà©", "‰Ω†ÂáªË¥•‰∫ÜBossÔºÅÊÅ≠ÂñúÈÄöÂÖ≥ÊâÄÊúâÂÖ≥Âç°ÔºÅÊ∏∏ÊàèÁªìÊùü!", buttonMap);
            }
        } else {
            // content == ENEMY || content == MINI_BOSS
            BattleRewardProcessor.showRandomRewardEnemy(this);
        }

        centerScroll();
        deckManager.endBattleSetUp();
        renderHand();
        // Ê≥®ÈîÄ Observers
        destroyBattleObservers();
    }

    public boolean isNeighbor(int playerX, int playerY, int x, int y) {
        return (Math.abs(playerX - x) + Math.abs(playerY - y)) == 1;
    }


    private void applySelectEffect(Button btn, VBox wrapper, boolean isSelected) {
        if (isSelected) {
            btn.setEffect(new DropShadow(10, Color.DARKBLUE));
            wrapper.setTranslateY(-10);
        } else {
            btn.setEffect(null);
            wrapper.setTranslateY(0);
        }
    }

    public void setAllBattleActionButtonsEnabled(boolean enabled) {
        endTurnBtn.setDisable(!enabled);
    }

    private void setAllBattleActionButtonsVisible(boolean enabled) {
        endTurnBtn.setVisible(enabled);
    }

    private void setAllMapActionEnabled(boolean enabled) {
        mapGrid.setDisable(!enabled);
        openInventoryButton.setDisable(!enabled);
    }

    @FXML
    private void onEndTurnClick() {
        if (engine.drawingNow || engine.getState() != PLAYER_TURN) return;

        setAllBattleActionButtonsEnabled(false);

        /* ÂÖàÂÅöÂä®ÁîªÔºöUI ÈÄêÂº†È£ûÂºÉÁâåÂ†Ü */
        cardAnimator.animateDiscardHand(
                handCardBox,
                // ÊØèÈ£ûÂÆå‰∏ÄÂº†ÔºåÈÄªËæëÂ±ÇÂºÉÁâå
                cv -> deckManager.discardCardInHand(cv.getCard()),
                () -> {                               // ÊâÄÊúâÂä®ÁîªÁªìÊùüÂêé ‚Üí ËøõÂÖ•ÊÄ™Áâ©ÂõûÂêà
                    renderHand();                     // Ê∏ÖÁ©∫ÊâãÁâå UIÔºà‰øùÈô©Ôºâ
                    // Ëß¶ÂèëÊÄ™Áâ©ÂõûÂêà, Êâ£Ë°Ä‰ºöËß¶Âèë updateUI() Âú® EventListenerÈáå
                    String log = engine.endPlayerTurn();
                    Log.write(log);
                    updateUI();                       // Âà∑ EP/HP Á≠â
                });
    }

    @FXML
    private void onRestartClick(ActionEvent event) {
        doRestartClick();
    }

    private void doRestartClick() {
        resetForNewGame();
        // ÂõûÂà∞ÈÄâ‰∫∫ÁïåÈù¢
        switchToMode(getUIState(engine.getState()));
    }
    public void backToMainMenu() {
        closeAllOverlays();
        resetForNewGame();
        switchToMode(MAIN_MENU_CONTROLLER);
    }

    public void resetForNewGame() {
        CardAnimator.resetSeq();
        destroyBattleObservers();
        engine.resetEngineToRoleSelect();
        player.getStatusManager().clearAllBuffs();
        triggerManager.clearAll();
        GameController.isFirstTime = true;
        deckManager.reset();
        clearHandUI();
        updateUI();
    }

    private void destroyBattleObservers() {
        if (playerObserver != null) {
            player.removeObserver(playerObserver);
            playerObserver = null;
        }
        if (engine.getMonster() != null && monsterObserver != null) {
            engine.getMonster().removeObserver(monsterObserver);
            monsterObserver = null;
        }
    }

    @FXML
    private void onBackToMap() {
        doBackToMap();
    }

    public void doBackToMap() {
        engine.setState(MAP_TURN_ENGINE);
        destroyBattleObservers();
        // ÂõûÂà∞Âú∞Âõæ
        switchToMode(MAP_TURN_CONTROLLER);

        updateUI();
    }

    @FXML
    private void onNextLevel(ActionEvent actionEvent) {
        doNextLevel();
    }

    private void doNextLevel() {
        if (engine.getState() == PAUSED_ENGINE) return;
        startNewLevel();
        centerScroll();
    }

    public void showInfoDialog(String title, String message, Map<String, Runnable> options) {
        OverlayUtil.openOverlay(rootPane, overlayStack,
                () -> new InfoOverlay(title, message, options));
    }

    private void registerGlobalEscHandler(Scene scene) {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (event.getCode() == KeyCode.ESCAPE) {
                toggleESCMenu();
                event.consume();
            }
        });
    }

    @FXML
    private void onNewGame() {
        mainMenuPane.setVisible(false); // ÈöêËóè‰∏ªËèúÂçï
        switchToMode(ROLE_SELECT_CONTROLLER); // ËøõÂÖ•ÈÄâ‰∫∫ÁïåÈù¢
    }

    @FXML
    private void onSettings() {
        OverlayUtil.openOverlay(rootPane, overlayStack, () -> {
            VBox content = new VBox(10);
            content.setAlignment(Pos.CENTER);
            content.getChildren().addAll(
                    new Label("ËÆæÁΩÆÁïåÈù¢ÔºàÊöÇÊú™ÂºÄÊîæÔºâ"),
                    new Button("ÂÖ≥Èó≠ËÆæÁΩÆ")
            );
            BaseOverlay overlay = new BaseOverlay(300, 200);
            overlay.getChildren().add(content);
            ((Button) content.getChildren().get(1)).setOnAction(e -> overlay.closeOverlay());
            return overlay;
        });
    }

    @FXML
    private void onExit() {
        Platform.exit();
    }

    private void toggleESCMenu() {
        long now = System.currentTimeMillis();
        if (now - lastEscPressTime < ESC_DEBOUNCE_MS) return; // ÂøΩÁï•ËøáÂø´Êåâ‰∏ã
        lastEscPressTime = now;

        if (isESCMenuOpen) {
            isESCMenuOpen = false;
            closePauseOverlay();
        } else {
            isESCMenuOpen = true;
            openPauseOverlay();
        }
    }

    private void openPauseOverlay() {
        pauseOverlay = OverlayUtil.openOverlay(rootPane, overlayStack, () -> new PauseOverlay(
                this::closePauseOverlay, // ÁªßÁª≠Ê∏∏Êàè
                this::doRestartClick,    // ÈáçÊñ∞ÂºÄÂßã
                this::backToMainMenu,
                this::exitGame));
        engine.pauseGame();
    }

    private void closePauseOverlay() {
        if (pauseOverlay != null) {
            pauseOverlay.closeOverlay();   // Ëß¶ÂèëÂÖàÂâç setOnClose ÂõûË∞ÉÔºådim+Á™ó‰∏ÄËµ∑ÁßªÈô§
            pauseOverlay = null;
        }
        engine.resumeGame();
    }

    // ÂÖ≥Èó≠ÊâÄÊúâÊµÆÁ™ó, ËÉåÂåÖ, ÂçäÈÄèÊòéÈÅÆÁΩ©
    private void closeAllOverlays() {
        while (!overlayStack.isEmpty()) {
            rootPane.getChildren().remove(overlayStack.pop());
        }
        pauseOverlay = null;
    }

    private void exitGame() {
        Platform.runLater(Platform::exit);
    }

    public Player getPlayer() {
        return this.player;
    }

    @FXML
    private void onOpenInventory() {
        OverlayUtil.openOverlay(rootPane, overlayStack, () -> {
            FXMLLoader loader = new FXMLLoader(getClass().getResource(
                    "/com/zixun/cardGame/view/full-inventory.fxml"));
            Parent inventoryRoot = null;
            try {
                inventoryRoot = loader.load();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            FullInventoryController controller = loader.getController();
            controller.initialize(player, deckManager.getAllCards(), player.getRelicList(), rootPane, overlayStack);

            BaseOverlay overlay = new BaseOverlay(600, 400);
            overlay.getChildren().add(inventoryRoot);
            controller.setOnCloseRequest(overlay::closeOverlay);
            return overlay;
        });
    }

    public void openShop() {
        OverlayUtil.openOverlay(rootPane, overlayStack, () -> {
            FXMLLoader loader = new FXMLLoader(getClass().getResource(
                    "/com/zixun/cardGame/view/shop-overlay.fxml"));
            Parent shopRoot = null;
            try {
                shopRoot = loader.load();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            ShopOverlayController controller = loader.getController();
            controller.initData(player, deckManager, rootPane, overlayStack);

            BaseOverlay overlay = new BaseOverlay(600, 400);
            overlay.getChildren().add(shopRoot);
            controller.setOnCloseRequest(() -> {
                overlay.closeOverlay();
                renderRelics();
            });
            controller.setOnUpdateUI(this::updateUI);

            return overlay;
        });
    }

    private GameControllerState getUIState(GameEngineState state) {
        return switch (state) {
            case ROLE_SELECT_ENGINE -> (currentMode == MAIN_MENU_CONTROLLER ?
                    MAIN_MENU_CONTROLLER : ROLE_SELECT_CONTROLLER);
            case MAP_TURN_ENGINE -> MAP_TURN_CONTROLLER;
            case PLAYER_TURN, ENEMY_TURN -> BATTLE_CONTROLLER;
            case GAME_OVER, PAUSED_ENGINE -> currentMode; // ÂÅúÁïôÂú®ÂΩìÂâçÈ°µÈù¢
        };
    }


    // Èº†Ê†á‰∫ã‰ª∂
    private CardView createInteractiveCardView(Card card) {
        CardView view = CardView.forCombat(card, player, CardViewSize.BATTLE);
        view.setHoverEffectEnabled(true);

        view.setOnMousePressed(e -> {
            if (e.getButton() == MouseButton.PRIMARY) beginCardDrag(view, e);
        });
        view.setOnMouseClicked(e -> {
            if (e.getButton() == MouseButton.SECONDARY) cancelCardDrag();
        });
        GameEngine engine = GameEngine.getInstance();
        boolean canOperate =
                engine.getState() == PLAYER_TURN &&
                        engine.getState() != PAUSED_ENGINE &&
                        engine.getState() != MAP_TURN_ENGINE;
        view.setDisable(!canOperate);
        return view;
    }

    public void beginCardDrag(CardView view, MouseEvent e) {
        if (dragPhase != DragPhase.NONE) return;   // ‰ªª‰ΩïÂä®Áîª‰∏≠ÈÉΩ‰∏çÂÜçÊé•ÂèóÊãñÊãΩ
        dragPhase = DragPhase.DRAGGING;

        if (draggingCard != null) return;
        if (!arrowReady) {            // ÊáíÂàùÂßãÂåñ
            initArrow();
            rootPane.getChildren().addAll(arrow, arrowHead);
            arrowReady = true;
        }

        draggingCard      = view;
        cardBeingDragged  = view.getCard();
        dragOriginParent  = (Pane) view.getParent();
        dragOriginIndex   = dragOriginParent.getChildren().indexOf(view);
        offsetX = offsetY = 0;  //  Âç°Áâå‰∏≠ÂøÉÊ∞∏ËøúÂØπÂáÜÈº†Ê†á
        //ËÆ∞‰∏ãÊãñËµ∑ÂâçÂç°ÁâåÂ∑¶‰∏äËßíÂú® rootPane ÂùêÊ†áÔºåÁî®‰∫éÂõû‰ΩçÂä®Áîª
        Bounds bScene = view.localToScene(view.getBoundsInLocal());
        returnPos = rootPane.sceneToLocal(bScene.getMinX(), bScene.getMinY());

        // ÊèêÂçáÂ±ÇÁ∫ß
        dragOriginParent.getChildren().remove(view);
        view.setManaged(false);
        rootPane.getChildren().add(view);

        //  Á´ãÂç≥ÊääÂç°ÁâåÊîæÂà∞Èº†Ê†áÊâÄÂú®‰ΩçÁΩÆ
        placeCardAt(e.getSceneX() - offsetX, e.getSceneY() - offsetY);

        // ÂÖ®Â±ÄÁõëÂê¨
        Scene sc = rootPane.getScene();
        sc.addEventFilter(MouseEvent.MOUSE_MOVED,  this::updateCardDrag);
        sc.addEventFilter(MouseEvent.MOUSE_PRESSED,this::globalMousePress); //  Âè≥ÈîÆÂÖúÂ∫ï
    }
    private void globalMousePress(MouseEvent e) {
        if (dragPhase != DragPhase.DRAGGING) return;

        if (cardBeingDragged == null) {
            e.consume();
            return;
        }

        /* 1) Âè≥ÈîÆ ‚áí Áõ¥Êé•ÂèñÊ∂à */
        if (e.getButton() == MouseButton.SECONDARY) {
            cancelCardDrag();
            e.consume();
            return;
        }

        /* 2) Â∑¶ÈîÆ ‚áí Âà§ÂÆöÂå∫Âüü & Âç°ÁâåÁõÆÊ†áÁ±ªÂûã */
        if (e.getButton() != MouseButton.PRIMARY) return;

        Bounds handB    = handCardBox.localToScene(handCardBox.getBoundsInLocal());
        boolean inHand  = handB.contains(e.getSceneX(), e.getSceneY());

        if (inHand) {                      // ‚Üê Áõ¥Êé•Êí§ÈîÄ
            finishCardDrag(true, null);
            e.consume();
            return;
        }

        TargetType type = cardBeingDragged.getTargetType();
        Bounds monsterB = monsterArea.localToScene(monsterArea.getBoundsInLocal());
        boolean inMonster = monsterB.contains(e.getSceneX(), e.getSceneY());

        /* Âà§ÂÆöËÉΩÂê¶Á´ãÂç≥‰ΩøÁî® */
        if (type == TargetType.NONE) {
            tryUseDraggedCard(null);         // Êó†ÁõÆÊ†áÂûã
            e.consume();
        } else if (type == TargetType.MONSTER && inMonster) {
            tryUseDraggedCard(engine.getMonster());   // Âè™Êúâ‰∏Ä‰∏™ÊÄ™Êó∂Áõ¥Êé•ÂºïÁî®
            e.consume();
        }
        // ÂÖ∂‰ΩôÊÉÖÂÜµÔºö‰øùÊåÅÊãñÊãΩÔºå‰∏çÂÅö‰ªª‰ΩïÂ§ÑÁêÜ
    }
    private void tryUseDraggedCard(Monster target) {
        Card played = cardBeingDragged;
        CardView cardNode = draggingCard;            // ÊãøÂú®Êâã‰∏äÁöÑËäÇÁÇπ
        cardNode.setHoverEffectEnabled(true);

        CardEffectResult result = engine.playerUseCard(played);  // ‰ΩøÁî®Âç°Áâå
        boolean success = result.success();
        if (!success) {                 //  EP ‰∏çÂ§ü / ÁõÆÊ†áÈùûÊ≥ï
            finishCardDrag(true, null);
            return;
        }

        updateBattleInfo(); // Êâ£ EP

        // Êï∞ÊçÆÂ§ÑÁêÜ UIÂà∑Êñ∞
        deckManager.tryToDiscard(played);
        updateUI();
        renderHand();

        // ÈáäÊîæÊãñÊãΩÈîÅ ÂÖÅËÆ∏Âä®Áîª‰∏≠Êìç‰ΩúÂÖ∂‰ªñÂç°Áâå
        clearDragState();

        boolean vanish = played.getExhaustAfterUse() || "ËÉΩÂäõ".equals(played.getType());
        if (vanish) {
            // ËÉΩÂäõÁâå Ê∂àÂ§±Áâå -> Ê∑°Âá∫Âä®Áîª
            cardAnimator.fadeAndRemove(cardNode, this::checkIfGameOver);
        } else {
            // ÊôÆÈÄöÁâå -> È£ûÂêëÂºÉÁâåÂ†Ü
            cardAnimator.flyToDiscard(cardNode, this::checkIfGameOver);
        }
    }

    private void clearDragState() {
        hideArrow();
        dragPhase = DragPhase.NONE;
        draggingCard = null;
        cardBeingDragged = null;
    }

    public void updateCardDrag(MouseEvent e) {
        if (dragPhase != DragPhase.DRAGGING || cardBeingDragged == null) return;
        currentMousePosition = new Point2D(e.getSceneX(), e.getSceneY());

        TargetType type = cardBeingDragged.getTargetType();   // NONE / MONSTER
        Bounds hand = handCardBox.localToScene(handCardBox.getBoundsInLocal());
        Bounds monsterB = monsterArea.localToScene(monsterArea.getBoundsInLocal());

        boolean mouseInsideHand = hand.contains(currentMousePosition);
        boolean mouseOverMonster = monsterB.contains(currentMousePosition);

        if (type == TargetType.NONE || mouseInsideHand) {
            // ÊôÆÈÄöË∑üÈöè
            draggingCard.setHoverEffectEnabled(true);
            placeCardAt(e.getSceneX() - offsetX, e.getSceneY() - offsetY);
            hideArrow();
        } else { // Âè™ËÉΩÊâìÊÄ™ Èº†Ê†áÂá∫‰∫ÜÊâãÁâåÂå∫
            draggingCard.setHoverEffectEnabled(false);
            snapCardToHandCenter(hand);
            showArrowToMouse(e);
            Color col = (type == TargetType.MONSTER && mouseOverMonster) ?
                        Color.web("#ff4d4f") : Color.web("#888888");
            arrow.setStroke(col);
            arrowHead.setFill(col);

            // Êõ¥Êñ∞ÊâãÁâå‰º§ÂÆ≥ÊòæÁ§∫ ÈôÑÂä† VULNERABLE Êï∞ÂÄº
            if (draggingCard != null && draggingCard instanceof CardView) {
                Monster hoverTarget = mouseOverMonster ? engine.getMonster() : null;
                draggingCard.setHoverTarget(hoverTarget);
                draggingCard.updateDescription();           // ÈáçÊñ∞Ê∏≤Êüì {damage} {block}
            }
        }
    }

    private void placeCardAt(double sceneX, double sceneY) {
        Point2D p = rootPane.sceneToLocal(sceneX, sceneY);
        draggingCard.relocate(p.getX() - draggingCard.getWidth() / 2,
                p.getY() - draggingCard.getHeight() / 2);
    }

    private void snapCardToHandCenter(Bounds hand) {
        if (!isAiming) {     // Á¨¨‰∏ÄÊ¨°ËøõÂÖ•ÁûÑÂáÜÁä∂ÊÄÅÊó∂ÊâçÊääÂç°ÁâåÂΩí‰Ωç
            Point2D centre = rootPane.sceneToLocal(
                    hand.getMinX() + hand.getWidth() / 2,
                    hand.getMinY() + hand.getHeight() / 2);
            draggingCard.relocate(centre.getX() - draggingCard.getWidth() / 2,
                    centre.getY() - draggingCard.getHeight() / 2);
            draggingCard.relocate(
                    centre.getX() - draggingCard.getWidth() / 2,
                    centre.getY() - draggingCard.getHeight() / 2 - hand.getHeight() * 0.25);
            isAiming = true;
        }
    }

    private void showArrowToMouse(MouseEvent e) {
        if (!rootPane.getChildren().contains(arrow)) {
            rootPane.getChildren().addAll(arrow, arrowHead);
        }

        /* Êää scene ÂùêÊ†áÁªü‰∏ÄËΩ¨Êç¢Êàê rootPane Êú¨Âú∞ÂùêÊ†á */
        Point2D start = rootPane.sceneToLocal(
                draggingCard.localToScene(
                        draggingCard.getWidth() / 2,
                        0));   // y=0 -> È°∂Ëæπ
        Point2D end = rootPane.sceneToLocal(e.getSceneX(), e.getSceneY());

        arrow.setStartX(start.getX()); arrow.setStartY(start.getY());
        final double GAP = ARROW_HEAD_H * 0.6;          // 0.6√óÁÆ≠Â§¥È´ò Âú®‰∏âËßíÈáåÊ∂àÂ§±
        double len = Math.hypot(end.getX() - start.getX(), end.getY() - start.getY());
        double ux  = (end.getX() - start.getX()) / len; // Âçï‰ΩçÂêëÈáè
        double uy  = (end.getY() - start.getY()) / len;
        arrow.setEndX(end.getX() - ux * GAP);
        arrow.setEndY(end.getY() - uy * GAP);

        /* ÁÆ≠Â§¥ÊúùÂêë‰∏é‰ΩçÁΩÆ */
        double dx = end.getX() - start.getX();
        double dy = end.getY() - start.getY();
        double angle = Math.atan2(dy, dx);

        arrowHead.getTransforms().setAll(
                new Rotate(Math.toDegrees(angle) - 90, 0, 0));
        arrowHead.setTranslateX(end.getX());
        arrowHead.setTranslateY(end.getY());
        arrowHead.setViewOrder(-1002);
    }

    private void hideArrow() {
        if (rootPane.getChildren().contains(arrow)) {
            rootPane.getChildren().removeAll(arrow, arrowHead);
            isAiming = false;
        }
    }
    private void finishCardDrag(boolean returnToHand, Runnable afterPlay) {
        if (dragPhase != DragPhase.DRAGGING || draggingCard == null) return;
        dragPhase = DragPhase.FLYING;                // Á´ãÂç≥ÈîÅÁä∂ÊÄÅ
        draggingCard.setHoverEffectEnabled(true);

        Scene sc = rootPane.getScene();
        sc.removeEventFilter(MouseEvent.MOUSE_MOVED,   this::updateCardDrag);
        sc.removeEventFilter(MouseEvent.MOUSE_PRESSED, this::globalMousePress);

        hideArrow();
        //draggingCard.setScaleX(1); draggingCard.setScaleY(1);

        if (returnToHand) {                       // ÂèñÊ∂àÊãñÊãΩ
            /* Âä®ÁîªÔºöÁßªÂä® + Áº©ÊîæÂõû 1.0 */
            CardView cardNode = draggingCard;

            cardAnimator.flyBackToHand(rootPane, cardNode, returnPos, () -> {
                rootPane.getChildren().remove(cardNode);
                cardNode.setTranslateX(0); cardNode.setTranslateY(0);
                cardNode.setManaged(true);
                if (cardNode.getParent() != dragOriginParent) {
                    dragOriginParent.getChildren()
                            .add(Math.min(dragOriginIndex,
                                            dragOriginParent.getChildren().size()),
                                    cardNode);
                }
                clearDragState();          // dragPhase = NONE, ÂºïÁî®Ê∏ÖÁ©∫
            });
        } else { // ÊàêÂäü‰ΩøÁî®
            // ÊääËäÇÁÇπ‰ªéÂéüÁà∂ÂÆπÂô®ÁßªÈô§ÔºåÈÅøÂÖç layout ÊääÂÆÉÂºπÂõûÊâãÁâå
            dragOriginParent.getChildren().remove(draggingCard); // Èò≤Ê≠¢ layout ÊäñÂä®
            if (afterPlay != null) afterPlay.run();         // ‰∫§Áªô tryUseDraggedCard ÂêéÁª≠Âä®Áîª
        }
    }

    public void cancelCardDrag() {
        if (dragPhase != DragPhase.DRAGGING) return;
        finishCardDrag(true, null);
    }

    private void initArrow() {
        arrow.setStrokeLineCap(StrokeLineCap.ROUND);
        arrow.setStrokeWidth(ARROW_THICKNESS);
        arrow.setManaged(false);
        arrow.setMouseTransparent(true);
        arrow.setViewOrder(-1000);

        arrowHead.setManaged(false);
        arrowHead.setStroke(Color.TRANSPARENT);
        arrowHead.setFill(Color.GRAY);
        arrowHead.toFront();
        arrowHead.getPoints().setAll(0.0,0.0, -13.0,-26.0, 13.0,-26.0);
        arrowHead.setMouseTransparent(true);
        arrowHead.setViewOrder(-1001);
    }

    private void clearHandUI() {
        handCardBox.getChildren().clear();
    }
    ///////re

    private void refreshExhaustCount() {
        cardInExhaustLabel.setText(String.valueOf(deckManager.getExhaustPile().size()));
    }

    @FXML
    private void onSelectWarrior() {
        // Áé©ÂÆ∂ÈÄâÊàòÂ£´ ÂàùÂßãÂåñÂÖ∂‰ªñ...
        player = new Player("ÈìÅË°ÄÊàòÂ£´");
        deckManager.reset();
        deckManager.initDeckForClass("warrior");
        initWithPlayerAndDeck(player);
        switchToMode(getUIState(engine.getState()));
    }

    @FXML
    private void onSelectMage() {
        player = new Player("mage");
        deckManager.reset();
        deckManager.initDeckForClass("mage");
        initWithPlayerAndDeck(player);
        switchToMode(getUIState(engine.getState()));
    }

    @FXML
    private void onSelectRogue() {
        player = new Player("rogue");
        deckManager.reset();
        deckManager.initDeckForClass("rogue");
        initWithPlayerAndDeck(player);
        switchToMode(getUIState(engine.getState()));
    }

    public StackPane getRootPane() {
        return rootPane;
    }

    public Deque<Node> getOverlayStack() {
        return overlayStack;
    }

    public DeckManager getDeckManager() {
        return deckManager;
    }

    public GameManager getGameManager() {
        return gameManager;
    }

    private void syncWidths(double per) {
        infoBar.getChildren().forEach(n -> ((Region) n).setPrefWidth(per));
        btnWarrior.setPrefWidth(per);
    }

    public void centerScroll() {
        Platform.runLater(() -> {
            Platform.runLater(() -> {
                MapNode playerNode = gameManager.getCurrentLevel().getLayeredGameMap().getPlayerNode();
                Button btn = nodeToButtonMap.get(playerNode);
                if (btn != null) {
                    centerScrollOn(mapScroll, btn);
                }
            });
        });
    }

    /** Êää scrollPane ÁöÑËßÜÂè£‰∏≠ÂøÉÂØπÈΩêÂà∞ node Â±èÂπï‰∏≠ÂøÉ */
    private void centerScrollOn(ScrollPane scroll, Node node) {
        Bounds contentBounds = scroll.getContent().localToScene(scroll.getContent().getBoundsInLocal());
        Bounds nodeBounds    = node.localToScene(node.getBoundsInLocal());

        double viewportH = scroll.getViewportBounds().getHeight();
        double viewportW = scroll.getViewportBounds().getWidth();

        double targetX = nodeBounds.getMinX() + nodeBounds.getWidth()  / 2.0;
        double targetY = nodeBounds.getMinY() + nodeBounds.getHeight() / 2.0;

        double hValue = (targetX - viewportW / 2 - contentBounds.getMinX())
                / (contentBounds.getWidth()  - viewportW);
        double vValue = (targetY - viewportH / 2 - contentBounds.getMinY())
                / (contentBounds.getHeight() - viewportH);

        scroll.setHvalue(clamp(hValue));
        scroll.setVvalue(clamp(vValue));
    }

    private double clamp(double v) { return Math.max(0, Math.min(1, v)); }

    public Label getCardInDeckLabel() {
        return cardInDeckLabel;
    }
    public CardAnimator getCardAnimator() {
        return cardAnimator;
    }
}
